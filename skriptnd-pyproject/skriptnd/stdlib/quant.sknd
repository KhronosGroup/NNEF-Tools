# Copyright (c) 2017-2025 The Khronos Group Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# @title quant-ops Quatization Operators

# @item Linear Quantization

operator zero_point_linear_quantize {
    @attrib {
        zero_point: int..(s[channel_axis]);
        scale: real..(s[channel_axis]);
        bits: int;
        signed: bool = true;
        symmetric: bool = false;
        channel_axis: int = 1;
    }
    @input {
        input: real[s..];
    }
    @output {
        output: real[s..];
    }
    @using {
        r = signed ? 2 ** (bits - 1) - 1 : 2 ** bits - 1;
        m = !signed ? 0 : symmetric ? -r : -r - 1;
        uz = zero_point := ..;
        us = scale := ..;
    }
    @assert {
        scale > 0.0: "scale must be positive", scale;
        bits > 0: "bits must be positive", bits;
    }
    @lower {
        with
            zp = uz ?? zero_point[i[channel_axis]],
            sc = us ?? scale[i[channel_axis]],
            quantized = zp + int(round(input[i..] / sc)) >> m << r:
        output[i..] = real(quantized - zp) * sc,
            i < s;
    }
}

operator min_max_linear_quantize {
    @attrib {
        min: real..(s[channel_axis]);
        max: real..(s[channel_axis]);
        bits: int;
        signed: bool = true;
        symmetric: bool = false;
        channel_axis: int = 1;
    }
    @input {
        input: real[s..];
    }
    @output {
        output: real[s..];
    }
    @using {
        r = real(2 ** bits - 1 - int(signed && symmetric));
        p = real(signed ? 2 ** (bits - 1) - int(symmetric) : 0);
        umin = min := ..;
        umax = max := ..;
    }
    @assert {
        bits > 0: "bits must be positive", bits;
    }
    @lower {
        with
            mn = umin ?? min[i[channel_axis]],
            mx = umax ?? max[i[channel_axis]],
            sc = mx - mn,
            quantized = round(((input[i..] >> mn << mx) - mn) / sc * r) - p:
        output[i..] = real((quantized + p) / r * sc + mn),
            i < s;
    }
}
